---
title: "Embracing the Vibe"
author: "Federico Caria"
date: "2025-05-21"
tags: ["coding", "AI", "product"]
summary: "Vibe coding is an evolution of the relationship between human creativity and computer precision. We’re still in the early days of this paradigm, but it’s unfolding fast."
---

###### Introduction
Vibe coding represents an interesting shift in software development where developers co-create code through natural language prompts rather than writing it manually. Thanks to tools like Cursor and Claude Code, we can now interact directly within IDEs or through terminals (it took quite sometime but the copy / paste drama seems to be over), creating a seamless experience where code materializes from conversation. The result? Lightning-fast prototypes and entire applications that materialize in a matter of hours.

### 1. Origin Story: From a Tweet to a Movement
The term "vibe coding" emerged from a viral tweet by AI researcher Andrej Karpathy in early February 2025. Karpathy described discovering "a new kind of coding" where you:

> "...fully give in to the vibes, embrace exponentials, and forget that the code even exists."

His approach was simple: describe changes in plain English, let AI generate the code, and habitually click *Accept All* without reading diffs. When errors occurred, he'd copy-paste error messages back as prompts for fixes. The *jaw-dropping* example? He built a working iOS app in Swift—despite zero iOS experience—in just one hour. Major publications quickly picked up the story, with headlines declaring *the hottest new programming language is English*.

## 2. The Vibe Coding Process
In its simplest form, vibe coding operates through conversational iteration:

- **Start with Vision**: describe what you want in plain language;
- **AI Generates Code**: first-pass implementation based on your prompt;
- **Review and Guide**: test output, provide natural language feedback;
- **Iterate**: refine through ongoing dialogue until satisfied.

This creates a fluid, improvisational flow where conversation becomes the new compilation step. 

#### 2.1. The Components
Il paradigma di interazione cambia dal copy / paste della preistoria allThis is made possible by context-awareness and subprocess? the LLMs can grep lines in multiple files, figure it out, and use subprocess to run commands [add a techical description of how this happens, how the parts are put together. 

#### 2.2. Vibe Coding vs Traditional Development
Dice bene Luke Wrobelski..paradigm shift. Volendo provare a comparare ....

| Aspect | Traditional Coding | Vibe Coding |
|--------|-------------------|-------------|
| **Abstraction Level** | Direct code writing with rigid syntax | Natural language descriptions translated to code |
| **Developer Role** | Architect, implementer, debugger | Guide, reviewer, intent communicator |
| **Mindset** | "How do I implement this?" | "Can AI implement this for me?" |
| **Speed** | Methodical, measured progress | Rapid prototyping, order-of-magnitude faster |
| **Code Understanding** | Full comprehension required | Working software first, understanding later |
| **Quality Control** | Careful design, review, testing | Move fast, iterate through conversation |


## 3. The Vibe Coding Mindset
Despite its growing adoption, vibe coding faces significant criticism from traditional developers:

- **Security concerns**: This stuff is just too vulnerable.
- **Integration**: "Someone I know used it in production and broke everything"
- **Skill degradation**: Junior developers won't learn fundamental programming concepts, or worst, "I interview junors and they do  not know how to code anymore / can't explain what's going on without an LLMs telling them.
- **Code quality**: AI-generated code lacks elegance and maintainability
- **Professional standards**: Real engineering requires rigorous understanding of implementation, "vibe coding is just about UI but programing is much more, eg. performance.
- **Copyright**: 

#### 3.1. Vibe Coding is Itchy
LinkedIn has become a battleground of hot takes about *vibe coding killing engineering*, warnings that *AI won't clean up the mess*, and prophecies of junior developers who *will never learn to debug, optimize, or architect for failure*. These posts share a common thread: they address a phantom individual who supposedly believes vibe coding and traditional engineering serve identical purposes. But where is this mythical fool who thinks you can vibe-code a banking system? The reality is more nuanced. Most critics secretly experiment with vibe coding while publicly dismissing it—a classic case of hedging bets. The defensive stance is understandable; it comes from professionals who built careers on skills they believed irreplaceable. If reading supportive comments makes them feel better, perhaps that's fine too. But this criticism fundamentally misses the point. It's the old musician ranting about digital plugins, the film photographer dismissing digital cameras, the traditional painter scorning digital art. The irony? These critics often had valid points about craft and quality—yet look where those industries ended up. 

#### 3.2. The Sweet Spot of Vibe Coding
Vibe coding isn't meant to replace development teams for complex products. Instead, out of the box, it's a treasure for:

- **Rapid prototyping**: Test ideas in hours, not weeks
- **Business validation**: Build MVPs to evaluate market fit
- **Learning and exploration**: Experiment with new technologies quickly
- **Automating tedious tasks**: Generate boilerplate and handle routine coding

Google recently suggested that product managers should vibe code directly rather than writing specifications. This isn't reckless—it's recognizing that many software tasks don't require deep technical expertise.  

## 4. Embracing the Vibe (and Knowing Its Limits)
Vibe coding excels as a spectrum tool rather than a replacement. Surely, it's fantastic for:

- Learning new frameworks quickly
- Prototyping and experimentation
- Low-stakes development projects
- Bridging the gap between technical and non-technical team members

As AI models improve and developers refine their prompting skills, vibe coding will likely become standard for many development tasks. The barrier to software creation has never been lower—both for experienced developers seeking speed and non-developers with ideas to build.
The smart approach? I'll talk about it in another post.



Core Principles of Clean Code:
Readability and Expressiveness: Code should be written in a clear and understandable way, using meaningful names and a logical structure. 
Simplicity: Code should be as simple as possible without sacrificing functionality. Avoid unnecessary complexity and strive for straightforward solutions. 
Modularity: Break down complex tasks into smaller, well-defined functions or modules. 
Testability: Clean code is designed to be easily testable, with minimal side effects. 
Avoid Duplication (DRY): Don't repeat the same logic in multiple places. Use functions or other techniques to reuse code. 
Comments: Use comments to explain the "why" behind the code, not the "what". Code should be self-documenting as much as possible. 
Consistency: Adhere to coding conventions and maintain a consistent style throughout the codebase. 
Remove Dead Code: Delete commented-out code and unused variables. 
Single Responsibility: Each function or class should have a single, well-defined purpose. 